# validated: 2024-10-07 TW e53db15a2003 software/hardware-apis/sensors/gyros-software.rst
block0: |
  // ADIS16448 plugged into the MXP port
  val gyro = ADIS16448_IMU()

block1: |
  // ADIS16470 plugged into the SPI port
  val gyro = ADIS16470_IMU()

block2: |
  // Creates an ADXRS450_Gyro object on the onboard SPI port
  val gyro = ADXRS450_Gyro()

block3: |
  // Creates an AnalogGyro object on port 0
  val gyro = AnalogGyro(0)

block4: |
  // navX MXP using SPI
  val gyro = AHRS(SPI.Port.kMXP)

block5: |
  // Pigeon is on CAN Bus with device ID 0
  val gyro = WPI_PigeonIMU(0)

  // OR (choose one or the other based on your connection)

  // TalonSRX is on CAN Bus with device ID 0
  val talon = TalonSRX(0)
  // Pigeon uses the talon created above
  val gyro = WPI_PigeonIMU(talon)

block6: |

  // Use gyro declaration from above
  override fun robotInit() {
    // Places a compass indicator for the gyro heading on the dashboard
    Shuffleboard.getTab("Example tab").add(gyro)
  }

block7: |
  // Use gyro declaration from above
  companion object {
    // The gain for a simple P loop
    const val P = 1
  }

  // Initialize motor controllers and drive
  val leftLeader = Spark(0)
  val leftFollower = Spark(1).also { leftLeader.addFollower(it) }
  val rightLeader =
      Spark(2).apply {
        // Invert the right side of the drivetrain. You might have to invert the other side
        inverted = true
      }
  val rightFollower = Spark(3).also { rightLeader.addFollower(it) }
  val drive = DifferentialDrive(leftLeader::set, rightLeader::set)

  override fun autonomousPeriodic() {
    // Setpoint is implicitly 0, since we don't want the heading to change
    val error = -gyro.getRate()
    // Drives forward continuously at half speed, using the gyro to stabilize the heading
    drive.tankDrive(.5 + P * error, .5 - P * error)
  }

block8: |
  companion object {
    // The gain for a simple P loop
    const val P = 1
  }

  // Use gyro declaration from above here
  // The heading of the robot when starting the motion
  var heading = gyro.angle
  // Initialize motor controllers and drive
  val left1 = Spark(0)
  val left2 = Spark(1)
  val right1 = Spark(2)
  val right2 = Spark(3)
  val leftMotors = MotorControllerGroup(left1, left2)
  val rightMotors = MotorControllerGroup(right1, right2).apply { inverted = true }
  val drive = DifferentialDrive(leftMotors, rightMotors)

  override fun autonomousInit() {
    // Set setpoint to current heading at start of auto
    heading = gyro.angle
  }

  override fun autonomousPeriodic() {
    val error = heading - gyro.angle
    // Drives forward continuously at half speed, using the gyro to stabilize the heading
    drive.tankDrive(.5 + P * error, .5 - P * error)
  }

block9: |
  companion object {
    // The gain for a simple P loop
    const val P = 0.05
  }

  // Use gyro declaration from above here
  // Initialize motor controllers and drive
  val left1 = Spark(0)
  val left2 = Spark(1)
  val right1 = Spark(2)
  val right2 = Spark(3)
  val leftMotors = MotorControllerGroup(left1, left2)
  val rightMotors = MotorControllerGroup(right1, right2).apply { inverted = true }
  val drive = DifferentialDrive(leftMotors, rightMotors)

  override fun autonomousPeriodic() {
    // Find the heading error setpoint is 90
    val error = 90 - gyro.angle
    // Turns the robot to face the desired direction
    drive.tankDrive(P * error, -P * error)
  }
