# validated: 2024-10-07 TW e53db15a2003 software/hardware-apis/sensors/encoders-software.rst
block0: |
  // Initializes an encoder on DIO pins 0 and 1
  // Defaults to 4X decoding and non-inverted
  val encoder = Encoder(0, 1)

block1: |
  // Initializes an encoder on DIO pins 0 and 1
  // 2X encoding and non-inverted
  val encoder = Encoder(0, 1, false, CounterBase.EncodingType.k2X)

block2: |
  val encoder =
      Encoder(0, 1, false, CounterBase.EncodingType.k2X).apply {
        // Configures the encoder to return a distance of 4 for every 256 pulses
        // Also changes the units of getRate
        distancePerPulse = 4.0 / 256.0
        // Configures the encoder to consider itself stopped when its rate is below 10
        setMinRate(10.0)
        // Reverses the direction of the encoder
        setReverseDirection(true)
        // Configures an encoder to average its period measurement over 5 samples
        // Can be between 1 and 127 samples
        samplesToAverage = 5
      }

block3: |
  // Gets the distance traveled
  encoder.distance 

block4: |
  // Gets the current rate of the encoder
  encoder.rate

block5: |
  // Gets whether the encoder is stopped
  encoder.stopped

block6: |
  // Gets the last direction in which the encoder moved
  encoder.direction

block7: |
  // Gets the current period of the encoder
  encoder.period

block8: |
  // Resets the encoder to read a distance of zero
  encoder.reset()

block9: |
  // Initializes a duty cycle encoder on DIO pins 0
  val encoder = DutyCycleEncoder(0)

block10: |
  // Configures the encoder to return a distance of 4 for every rotation
  encoder. distancePerRotation = 4.0  

block11: |
  // Gets the distance traveled
  encoder.distance

block12: |
  // Gets if the encoder is connected
  encoder.isConnected

block13: |
  // Resets the encoder to read a distance of zero at the current position
  encoder.reset()
  // get the position offset from when the encoder was reset
  encoder.positionOffset
  // set the position offset to half a rotation
  encoder.positionOffset = 0.5

block14: |
  // Initializes an analog encoder on Analog Input pin 0
  val encoder = AnalogEncoder(0)

block15: |
  // Configures the encoder to return a distance of 4 for every rotation
  encoder.distancePerRotation = 4..0 

block16: |
  // Gets the distance measured
  encoder.getDistance()

block17: |
  // Resets the encoder to read a distance of zero at the current position
  encoder.reset()
  // get the position offset from when the encoder was reset
  encoder.positionOffset
  // set the position offset to half a rotation
  encoder.positionOffset = 0.5

block18: |
  // Creates an encoder on DIO ports 0 and 1
  val encoder =
      Encoder(0, 1).apply {
        // Configures the encoder's distance-per-pulse
        // The robot moves forward 1 foot per encoder rotation
        // There are 256 pulses per encoder rotation
        distancePerPulse = 1.0 / 256.0
      }
  // Initialize motor controllers and drive
  val leftLeader = Spark(0)
  val leftFollower = Spark(1).also { leftLeader.addFollower(it) }
  val rightLeader =
      Spark(2).apply {
        // Invert the right side of the drivetrain. You might have to invert the other side
        inverted = true
      }
  val rightFollower = Spark(3).also { rightLeader.addFollower(it) }
  val drive = DifferentialDrive(leftLeader::set, rightLeader::set)

  override fun autonomousPeriodic() {
    // Drives forward at half speed until the robot has moved 5 feet, then stops:
    if (encoder.distance < 5) {
      drive.tankDrive(0.5, 0.5)
    } else {
      drive.tankDrive(0.0, 0.0)
    }
  }

block19: |
  val encoder = Encoder(0, 1)
  val spark = Spark(0)
  // Limit switch on DIO 2
  val limit = DigitalInput(2)

  override fun autonomousPeriodic() {
    // Runs the motor backwards at half speed until the limit switch is pressed
    // then turn off the motor and reset the encoder
    if (!limit.get()) {
      spark.set(-0.5)
    } else {
      spark.set(0.0)
      encoder.reset()
    }
  }
