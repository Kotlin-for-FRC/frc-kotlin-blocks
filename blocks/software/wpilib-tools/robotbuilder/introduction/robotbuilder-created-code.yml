"block0": |-
  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
      m_chooser.setDefaultOption("Autonomous", new Autonomous());
      // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

      SmartDashboard.putData("Auto Mode", m_chooser);
"block1": |-
  // ROBOTBUILDER TYPE: Robot.
"block2": ":linenos:\n        :lineno-start: 11\n        :emphasize-lines: 19,50,70-75\n\
  \        \n        // ROBOTBUILDER TYPE: Robot.\n\n        package frc.robot;\n\n\
  \        import edu.wpi.first.hal.FRCNetComm.tInstances;\n        import edu.wpi.first.hal.FRCNetComm.tResourceType;\n\
  \        import edu.wpi.first.hal.HAL;\n        import edu.wpi.first.wpilibj.TimedRobot;\n\
  \        import edu.wpi.first.wpilibj2.command.Command;\n        import edu.wpi.first.wpilibj2.command.CommandScheduler;\n\
  \n        /**\n         * The VM is configured to automatically run this class,\
  \ and to call the\n         * functions corresponding to each mode, as described\
  \ in the TimedRobot\n         * documentation. If you change the name of this class\
  \ or the package after\n         * creating this project, you must also update the\
  \ build.properties file in\n         * the project.\n         */\n        public\
  \ class Robot extends TimedRobot { // (1)\n\n            private Command m_autonomousCommand;\n\
  \n            private RobotContainer m_robotContainer;\n\n            /**\n    \
  \         * This function is run when the robot is first started up and should be\n\
  \             * used for any initialization code.\n             */\n           \
  \ @Override\n            public void robotInit() {\n                // Instantiate\
  \ our RobotContainer.  This will perform all our button bindings, and put our\n\
  \                // autonomous chooser on the dashboard.\n                m_robotContainer\
  \ = RobotContainer.getInstance();\n                HAL.report(tResourceType.kResourceType_Framework,\
  \ tInstances.kFramework_RobotBuilder);\n            }\n\n            /**\n     \
  \       * This function is called every robot packet, no matter the mode. Use this\
  \ for items like\n            * diagnostics that you want ran during disabled, autonomous,\
  \ teleoperated and test.\n            *\n            * <p>This runs after the mode\
  \ specific periodic functions, but before\n            * LiveWindow and SmartDashboard\
  \ integrated updating.\n            */\n            @Override\n            public\
  \ void robotPeriodic() {\n                // Runs the Scheduler.  This is responsible\
  \ for polling buttons, adding newly-scheduled\n                // commands, running\
  \ already-scheduled commands, removing finished or interrupted commands,\n     \
  \           // and running subsystem periodic() methods.  This must be called from\
  \ the robot's periodic\n                // block in order for anything in the Command-based\
  \ framework to work.\n                CommandScheduler.getInstance().run();  //\
  \ (2)\n            }\n\n\n            /**\n            * This function is called\
  \ once each time the robot enters Disabled mode.\n            */\n            @Override\n\
  \            public void disabledInit() {\n            }\n\n            @Override\n\
  \            public void disabledPeriodic() {\n            }\n\n            /**\n\
  \            * This autonomous runs the autonomous command selected by your {@link\
  \ RobotContainer} class.\n            */\n            @Override\n            public\
  \ void autonomousInit() {\n                m_autonomousCommand = m_robotContainer.getAutonomousCommand();\
  \  // (3)\n\n                // schedule the autonomous command (example)\n    \
  \            if (m_autonomousCommand != null) {\n                    m_autonomousCommand.schedule();\n\
  \                }\n            }\n\n            /**\n            * This function\
  \ is called periodically during autonomous.\n            */\n            @Override\n\
  \            public void autonomousPeriodic() {\n            }\n\n            @Override\n\
  \            public void teleopInit() {\n                // This makes sure that\
  \ the autonomous stops running when\n                // teleop starts running. If\
  \ you want the autonomous to\n                // continue until interrupted by another\
  \ command, remove\n                // this line or comment it out.\n           \
  \     if (m_autonomousCommand != null) {\n                    m_autonomousCommand.cancel();\n\
  \                }\n            }\n\n            /**\n             * This function\
  \ is called periodically during operator control.\n             */\n           \
  \ @Override\n            public void teleopPeriodic() {\n            }\n\n     \
  \       @Override\n            public void testInit() {\n                // Cancels\
  \ all running commands at the start of test mode.\n                CommandScheduler.getInstance().cancelAll();\n\
  \            }\n\n            /**\n            * This function is called periodically\
  \ during test mode.\n            */\n            @Override\n            public void\
  \ testPeriodic() {\n            }\n\n        }"
"block3": |-
  :linenos:
          :lineno-start: 11
          :emphasize-lines: 33-36, 39, 62, 81, 92, 112

          // ROBOTBUILDER TYPE: RobotContainer.

          package frc.robot;

          import frc.robot.commands.*;
          import frc.robot.subsystems.*;
          import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
          import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
          import edu.wpi.first.wpilibj2.command.Command.InterruptionBehavior;

          // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
          import edu.wpi.first.wpilibj2.command.Command;
          import edu.wpi.first.wpilibj2.command.InstantCommand;
          import edu.wpi.first.wpilibj.Joystick;
          import edu.wpi.first.wpilibj2.command.button.JoystickButton;
          import frc.robot.subsystems.*;

              // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


          /**
           * This class is where the bulk of the robot should be declared.  Since Command-based is a
           * "declarative" paradigm, very little robot logic should actually be handled in the {@link Robot}
           * periodic methods (other than the scheduler calls).  Instead, the structure of the robot
           * (including subsystems, commands, and button mappings) should be declared here.
           */
          public class RobotContainer {

            private static RobotContainer m_robotContainer = new RobotContainer();

              // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
          // The robot's subsystems
              public final Wrist m_wrist = new Wrist(); // (1)
              public final Elevator m_elevator = new Elevator();
              public final Claw m_claw = new Claw();
              public final Drivetrain m_drivetrain = new Drivetrain();

          // Joysticks
          private final Joystick joystick2 = new Joystick(2); // (3)
          private final Joystick joystick1 = new Joystick(1);
          private final Joystick logitechController = new Joystick(0);

              // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


            // A chooser for autonomous commands
            SendableChooser<Command> m_chooser = new SendableChooser<>();

            /**
            * The container for the robot.  Contains subsystems, OI devices, and commands.
            */
            private RobotContainer() {
                  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
              // Smartdashboard Subsystems
              SmartDashboard.putData(m_wrist); // (6)
              SmartDashboard.putData(m_elevator);
              SmartDashboard.putData(m_claw);
              SmartDashboard.putData(m_drivetrain);


              // SmartDashboard Buttons
              SmartDashboard.putData("Close Claw", new CloseClaw( m_claw )); // (6)
              SmartDashboard.putData("Open Claw: OpenTime", new OpenClaw(1.0, m_claw));
              SmartDashboard.putData("Pickup", new Pickup());
              SmartDashboard.putData("Place", new Place());
              SmartDashboard.putData("Prepare To Pickup", new PrepareToPickup());
              SmartDashboard.putData("Set Elevator Setpoint: Bottom", new SetElevatorSetpoint(0, m_elevator));
              SmartDashboard.putData("Set Elevator Setpoint: Platform", new SetElevatorSetpoint(0.2, m_elevator));
              SmartDashboard.putData("Set Elevator Setpoint: Top", new SetElevatorSetpoint(0.3, m_elevator));
              SmartDashboard.putData("Set Wrist Setpoint: Horizontal", new SetWristSetpoint(0, m_wrist));
              SmartDashboard.putData("Set Wrist Setpoint: Raise Wrist", new SetWristSetpoint(-45, m_wrist));
              SmartDashboard.putData("Drive: Straight3Meters", new Drive(3, 0, m_drivetrain));
              SmartDashboard.putData("Drive: Place", new Drive(Drivetrain.PlaceDistance, Drivetrain.BackAwayDistance, m_drivetrain));

              // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
              // Configure the button bindings
              configureButtonBindings();

              // Configure default commands
                  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SUBSYSTEM_DEFAULT_COMMAND
              m_drivetrain.setDefaultCommand(new TankDrive(() -> getJoystick1().getY(), () -> getJoystick2().getY(), m_drivetrain)); // (5)


              // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SUBSYSTEM_DEFAULT_COMMAND

              // Configure autonomous sendable chooser
                  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

              m_chooser.addOption("Set Elevator Setpoint: Bottom", new SetElevatorSetpoint(0, m_elevator));
              m_chooser.addOption("Set Elevator Setpoint: Platform", new SetElevatorSetpoint(0.2, m_elevator));
              m_chooser.addOption("Set Elevator Setpoint: Top", new SetElevatorSetpoint(0.3, m_elevator));
              m_chooser.setDefaultOption("Autonomous", new Autonomous()); // (2)

              // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

              SmartDashboard.putData("Auto Mode", m_chooser);
            }

            public static RobotContainer getInstance() {
              return m_robotContainer;
            }

            /**
             * Use this method to define your button->command mappings.  Buttons can be created by
             * instantiating a {@link GenericHID} or one of its subclasses ({@link
             * edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then passing it to a
             * {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}.
             */
            private void configureButtonBindings() {
                  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
          // Create some buttons
          final JoystickButton r1 = new JoystickButton(logitechController, 12);        // (4)
          r1.onTrue(new Autonomous().withInterruptBehavior(InterruptionBehavior.kCancelSelf));

          final JoystickButton l1 = new JoystickButton(logitechController, 11);
          l1.onTrue(new Place().withInterruptBehavior(InterruptionBehavior.kCancelSelf));

          final JoystickButton r2 = new JoystickButton(logitechController, 10);
          r2.onTrue(new Pickup().withInterruptBehavior(InterruptionBehavior.kCancelSelf));

          final JoystickButton l2 = new JoystickButton(logitechController, 9);
          l2.onTrue(new PrepareToPickup().withInterruptBehavior(InterruptionBehavior.kCancelSelf));

          final JoystickButton dpadLeft = new JoystickButton(logitechController, 8);
          dpadLeft.onTrue(new OpenClaw(1.0, m_claw).withInterruptBehavior(InterruptionBehavior.kCancelSelf));

          final JoystickButton dpadRight = new JoystickButton(logitechController, 6);
          dpadRight.onTrue(new CloseClaw( m_claw ).withInterruptBehavior(InterruptionBehavior.kCancelSelf));

          final JoystickButton dpadDown = new JoystickButton(logitechController, 7);
          dpadDown.onTrue(new SetElevatorSetpoint(0, m_elevator).withInterruptBehavior(InterruptionBehavior.kCancelSelf));

          final JoystickButton dpadUp = new JoystickButton(logitechController, 5);
          dpadUp.onTrue(new SetElevatorSetpoint(0.3, m_elevator).withInterruptBehavior(InterruptionBehavior.kCancelSelf));



              // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
            }

              // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS
          public Joystick getLogitechController() {
                  return logitechController;
              }

          public Joystick getJoystick1() {
                  return joystick1;
              }

          public Joystick getJoystick2() {
                  return joystick2;
              }


              // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

            /**
             * Use this to pass the autonomous command to the main {@link Robot} class.
             *
             * @return the command to run in autonomous
            */
            public Command getAutonomousCommand() {
              // The selected command will be run in autonomous
              return m_chooser.getSelected();
            }


          }
