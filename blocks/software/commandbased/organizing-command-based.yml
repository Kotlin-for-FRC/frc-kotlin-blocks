block0: |
    val runIntake = Commands.startEnd({ intake.set(1) }, { intake.set(0.0) }, intake)

block1: |
    // RobotContainer.kt
    intakeButton.whileTrue(Commands.startEnd({ intake.set(1.0) }, { intake.set(0.0) }, intake))
    val intakeAndShoot = Commands.startEnd({ intake.set(1.0) }, { intake.set(0.0) }, intake)
        .alongWith(RunShooter(shooter))
    val autonomousCommand = Commands.sequence(
        Commands.startEnd({ intake.set(1.0) }, { intake.set(0.0) }, intake).withTimeout(5.0),
        Commands.waitSeconds(3.0),
        Commands.startEnd({ intake.set(1.0) }, { intake.set(0.0) }, intake).withTimeout(5.0)
    )

block2: |
    class Intake: SubsystemBase() {
      // [code for motor controllers, configuration, etc.]
      // ...
      fun runIntakeCommand() =
        this.startEnd({ this.set(1.0) }, { this.set(0.0) }) // implicitly requires `this`
    }

block3: |
    intakeButton.whileTrue(intake.runIntakeCommand())
    val intakeAndShoot = intake.runIntakeCommand().alongWith(RunShooter(shooter))
    val autonomousCommand = Commands.sequence(
        intake.runIntakeCommand().withTimeout(5.0),
        Commands.waitSeconds(3.0),
        intake.runIntakeCommand().withTimeout(5.0)
    )

block4: |
    public fun runIntakeCommand(percent: Double) =
        StartEndCommand({ this.set(percent) }, { this.set(0.0) }, this)

block5: |
    val intakeRunSequence = intake.runIntakeCommand(1.0).withTimeout(2.0)
        .andThen(Commands.waitSeconds(2.0))
        .andThen(intake.runIntakeCommand(-1.0).withTimeout(5.0))

block6: |
    fun driveAndIntakeRoutine(drivetrain: Drivetrain, intake: Intake) =
        Commands.sequence(
            Commands.parallel(
                drivetrain.driveCommand(0.5, 0.5),
                intake.runIntakeCommand(1.0)
            ).withTimeout(5.0),
            Commands.parallel(
                drivetrain.stopCommand(),
                intake.stopCommand()
            )
        )

block7: |
    class AutoRoutines(
        private val drivetrain: Drivetrain,
        private val intake: Intake
    ) { 
        fun driveAndIntake() = 
            Commands.sequence(
                Commands.parallel(
                    drivetrain.driveCommand(0.5, 0.5),
                    intake.runIntakeCommand(1.0)
                ).withTimeout(5.0),
                Commands.parallel(
                    drivetrain.stopCommand()
                    intake.stopCommand()
                )
            )
        fun driveThenIntake() = 
            Commands.sequence(
                drivetrain.driveCommand(0.5, 0.5).withTimeout(5.0),
                drivetrain.stopCommand(),
                intake.runIntakeCommand(1.0).withTimeout(5.0),
                intake.stopCommand()
            )
    }

block8: |
    val autoRoutines = AutoRoutines(this.drivetrain, this.intake)
    val driveAndIntake = autoRoutines.driveAndIntake()
    val driveThenIntake = autoRoutines.driveThenIntake()
    val drivingAndIntakingSequence = Commands.sequence(
        autoRoutines.driveAndIntake(),
        autoRoutines.driveThenIntake()
    )

block9: |
    const val TURN_TO_ANGLE_P = 0.5
    const val TURN_TO_ANGLE_TOLERANCE = 0.06
    fun turnToAngle(targetDegrees: Double) {
        // Create a controller for the inline command to capture
        val controller = PIDController(TURN_TO_ANGLE_P, 0.0, 0.0)
        // We can do whatever configuration we want on the created state before returning from the factory
        controller.setPositionTolerance(TURN_TO_ANGLE_TOLERANCE)
        // Try to turn at a rate proportional to the heading error until we're at the setpoint, then stop
        return run { arcadeDrive(0.0, -controller.calculate(gyro.heading, targetDegrees)) }
            .until(controller::atSetpoint)
            .andThen(runOnce{ arcadeDrive(0.0, 0.0) })
    }

block10: |
    class RunIntakeCommand(private val intake: Intake): Command() {
        init { addRequirements(intake) }
        override initialize() {
            intake.set(1.0)
        }
        override fun end(interrupted: Boolean) {
            intake.set(0.0)
        }
        // execute() defaults to do nothing
        // isFinished() defaults to return false
    }

block11: |
    class IntakeThenOuttake(intake: Intake): 
        SequentialCommandGroup(
            intake.runIntakeCommand(1.0).withTimeout(2.0),
            WaitCommand(2.0),
            intake.runIntakeCommand(-1).withTimeout(5.0)
        )
