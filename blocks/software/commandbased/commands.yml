block0: |
    Commands.run(intake::activate, intake)
    Commands.run({
        shooter.shoot()
        intake.stop()
    }, shooter, intake)

block1: |
    val mayRunDuringDisabled = Commands.run(::updateTelemetry).ignoringDisable(true)

block2: |
    val nonInterruptible = 
        Commands.run(intake::activate, intake)
            .withInterruptBehavior(Command.InterruptBehavior.kCancelIncoming)

block3: |
    // A split-stick arcade command, with forward/backward controlled by the left
    // hand, and turning controlled by the right.
    RunCommand({
        robotDrive.arcadeDrive(
            -driverController.getLeftY(),
            driverController.getRightX()
        )
    }, robotDrive)

block4: |
    Commands.startEnd(
        // Start a flywheel spinning at 50% power
        { shooter.shooterSpeed(0.5) },
        // Stop the flywheel at the end of the command
        { shooter.shooterSpeed(0.0) },
        // Requires the shooter subsystem
        shooter
    )

block5: |
    FunctionalCommand(
        // Reset encoders on command start
        /* onInit */ robotDrive::resetEncoders,
        // Start driving forward at the start of the command
        /* onExecute */ { robotDrive.arcadeDrive(kAutoDriveSpeed, 0) },
        // Stop driving at the end of the command
        /* onEnd */ { interrupted -> robotDrive.arcadeDrive(0, 0) },
        // End the command when the robot's driven distance exceeds the desired value
        /* isFinished */ { robotDrive.averageEncoderDistance >= kAutoDriveDistanceInches },
        // Require the drive subsystem
        /* subsystems */ robotDrive
    )

block6: |
    // Ends 5 seconds after being scheduled
    WaitCommand(5.0)

block7: |
    // Ends after both limitSwitch.get() and shooter.isReady() return true
    WaitUntilCommand{ limitSwitch.get() && shooter.isReady() }
